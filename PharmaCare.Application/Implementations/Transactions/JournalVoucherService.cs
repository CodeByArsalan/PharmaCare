using Microsoft.EntityFrameworkCore;
using PharmaCare.Application.DTOs.Transactions;
using PharmaCare.Application.Interfaces;
using PharmaCare.Application.Interfaces.Transactions;
using PharmaCare.Domain.Entities.Transactions;

namespace PharmaCare.Application.Implementations.Transactions;

public class JournalVoucherService : IJournalVoucherService
{
    private readonly IRepository<Voucher> _voucherRepository;
    private readonly IRepository<VoucherType> _voucherTypeRepository;
    private readonly IUnitOfWork _unitOfWork;

    public JournalVoucherService(
        IRepository<Voucher> voucherRepository,
        IRepository<VoucherType> voucherTypeRepository,
        IUnitOfWork unitOfWork)
    {
        _voucherRepository = voucherRepository;
        _voucherTypeRepository = voucherTypeRepository;
        _unitOfWork = unitOfWork;
    }

    public async Task<IEnumerable<Voucher>> GetAllJournalVouchersAsync()
    {
        // Get all vouchers of type 'JV'
        // Include type to verify? Or just filter by non-auto-generated?
        // Assuming "JV" is the code for manual journals.
        
        return await _voucherRepository.Query()
            .Include(v => v.VoucherType)
            .Where(v => v.VoucherType.Code == "JV")
            .OrderByDescending(v => v.VoucherDate)
            .ThenByDescending(v => v.CreatedBy) // approximate order
            .ToListAsync();
    }

    public async Task<Voucher?> GetByIdAsync(int id)
    {
        return await _voucherRepository.Query()
            .Include(v => v.VoucherDetails)
                .ThenInclude(vd => vd.Account)
            .Include(v => v.VoucherType)
            .FirstOrDefaultAsync(v => v.VoucherID == id);
    }

    public async Task<Voucher> CreateJournalVoucherAsync(JournalVoucherDto model, int userId)
    {
        // 1. Get JV Type
        var jvType = await _voucherTypeRepository.GetByIdAsync(model.VoucherType_ID);
        if (jvType == null)
            throw new Exception("Voucher Type not found.");
        
        if (jvType.IsAutoGenerated)
             throw new Exception("Cannot manually create an auto-generated voucher type.");

        // 2. Map ViewModel to Entity
        var voucher = new Voucher
        {
            VoucherType_ID = jvType.VoucherTypeID,
            VoucherNo = await GenerateVoucherNoAsync(),
            VoucherDate = model.VoucherDate,
            Narration = model.Narration,
            Status = "Posted",
            TotalDebit = model.TotalDebit,
            TotalCredit = model.TotalCredit,
            IsReversed = false,
            CreatedAt = DateTime.Now,
            CreatedBy = userId
        };

        // 3. Add Details
        foreach (var det in model.VoucherDetails)
        {
            voucher.VoucherDetails.Add(new VoucherDetail
            {
                Account_ID = det.Account_ID,
                DebitAmount = det.DebitAmount,
                CreditAmount = det.CreditAmount,
                Description = det.Description
            });
        }

        // 4. Save
        await _voucherRepository.AddAsync(voucher);
        await _unitOfWork.SaveChangesAsync();

        return voucher;
    }

    public async Task<bool> VoidVoucherAsync(int voucherId, string reason, int userId)
    {
        var original = await GetByIdAsync(voucherId);
        if (original == null) return false;
        if (original.IsReversed) return false; // Already reversed

        // 1. Mark Original as Reversed
        original.IsReversed = true;
        original.Status = "Reversed";
        original.VoidReason = reason;
        
        // 2. Create Reversal Voucher
        var reversal = new Voucher
        {
            VoucherType_ID = original.VoucherType_ID,
            VoucherNo = (await GenerateVoucherNoAsync()) + "-R", // or generate new sequence
            VoucherDate = DateTime.Now, // Reversal date is NOW
            Narration = $"Reversal of {original.VoucherNo} - {reason}",
            Status = "Posted", // The reversal itself is a valid posted transaction
            TotalDebit = original.TotalCredit, // Swapped for header? Usually header totals are just sum of lines. 
            // Actually, TotalDebit/Credit in header usually represents the volume. 
            // But let's stick to simple sum.
            TotalCredit = original.TotalDebit, 
            IsReversed = false,
            ReversesVoucher_ID = original.VoucherID,
            CreatedAt = DateTime.Now,
            CreatedBy = userId
        };
        
        // 3. Create Reversal Details (Swap Debit/Credit)
        foreach (var det in original.VoucherDetails)
        {
            reversal.VoucherDetails.Add(new VoucherDetail
            {
                Account_ID = det.Account_ID,
                DebitAmount = det.CreditAmount, // Swap
                CreditAmount = det.DebitAmount, // Swap
                Description = $"Reversal: {det.Description}"
            });
        }

        await _voucherRepository.AddAsync(reversal);
        // Note: effectively we need to save Reversal first to get ID? 
        // EF Core handles ID fixup. But we need to link Original.ReversedBy -> Reversal.
        
        // We add Reversal, then update Original.ReversedBy
        
        await _unitOfWork.SaveChangesAsync(); // Save Reversal to get ID
        
        original.ReversedByVoucher_ID = reversal.VoucherID; // Link
        _voucherRepository.Update(original);
        
        await _unitOfWork.SaveChangesAsync(); // Update Original

        return true;
    }

    public async Task<string> GenerateVoucherNoAsync()
    {
        // Simple generation: JV-yyyyMMdd-XXXX
        var prefix = $"JV-{DateTime.Now:yyyyMMdd}-";
        
        var lastVoucher = await _voucherRepository.Query()
            .Where(v => v.VoucherNo.StartsWith(prefix))
            .OrderByDescending(v => v.VoucherNo)
            .FirstOrDefaultAsync();

        int nextNum = 1;
        if (lastVoucher != null)
        {
            var parts = lastVoucher.VoucherNo.Split('-');
            if (parts.Length > 2 && int.TryParse(parts.Last(), out int lastNum))
            {
                nextNum = lastNum + 1;
            }
        }

        return $"{prefix}{nextNum:D4}";
    }
}
